<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Hearts & Love Words</title>
    <style>
        html, body {
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
            overflow: hidden;
            background: #000;
            /* Gi·ªØ touch-action v√† user-select ƒë·ªÉ tr√°nh c√°c v·∫•n ƒë·ªÅ m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát */
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            /* Lo·∫°i b·ªè perspective n·∫øu kh√¥ng c·∫ßn hi·ªáu ·ª©ng xoay 3D tr√™n container */
             perspective: 1000px;  
        }
        canvas { display: block; }

        #scene-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            /* Lo·∫°i b·ªè transform-style v√† transform v√¨ kh√¥ng c√≤n xoay container */
             transform-style: preserve-3d; 
             transform: rotateX(0deg) rotateY(0deg); 
             transition: transform 0.1s ease-out; 
             transform-origin: center center; 
        }
    </style>
</head>
<body>

<div id="scene-container">
    <canvas id="c"></canvas>
</div>

<script>
const loveWords = [
    "Anh th∆∞∆°ng em nhi·ªÅu l·∫Øm üíñ",
    "Ch·ªâ c·∫ßn l√† em, anh ch·∫•p nh·∫≠n t·∫•t c·∫£.",
    "Em l√† ƒëi·ªÅu ng·ªçt ng√†o nh·∫•t trong cu·ªôc ƒë·ªùi anh.",
    "M·ªói ng√†y c√≥ em l√† m·ªói ng√†y h·∫°nh ph√∫c.",
    "Anh ch·ªâ mu·ªën n·∫Øm tay em ƒëi h·∫øt cu·ªôc ƒë·ªùi n√†y.",
    "G·∫∑p ƒë∆∞·ª£c em l√† ƒëi·ªÅu may m·∫Øn nh·∫•t ƒë·ªùi anh.",
    "Anh mu·ªën ·ªü b√™n em, m√£i m√£i kh√¥ng r·ªùi.",
    "Ch·ªâ c·∫ßn em c∆∞·ªùi, c·∫£ th·∫ø gi·ªõi c·ªßa anh s√°ng l√™n.",
    "Em c√≥ bi·∫øt anh nh·ªõ em ƒë·∫øn nh∆∞·ªùng n√†o kh√¥ng?",
    "Em l√† gi·∫•c m∆° ƒë·∫πp nh·∫•t c·ªßa anh.",
    "D√π th·∫ø n√†o ƒëi n·ªØa, anh v·∫´n lu√¥n ·ªü ƒë√¢y v√¨ em.",
    "Y√™u em l√† ƒëi·ªÅu tuy·ªát v·ªùi nh·∫•t anh t·ª´ng l√†m.",
    "Anh h·ª©a s·∫Ω lu√¥n b√™n em, b·∫£o v·ªá v√† y√™u em.",
    "Tim anh ƒë√£ l·ª° nh·ªãp k·ªÉ t·ª´ ng√†y g·∫∑p em.",
    "Th·∫ø gi·ªõi n√†y ƒë·∫πp h∆°n v√¨ c√≥ em.",
    "Anh y√™u em h∆°n c·∫£ ng√¥n t·ª´ c√≥ th·ªÉ di·ªÖn t·∫£.",
    "Ch·ªâ c·∫ßn l√† em, m·ªçi ƒëi·ªÅu ƒë·ªÅu tr·ªü n√™n ƒë√°ng gi√°.",
    "Kh√¥ng ai thay th·∫ø ƒë∆∞·ª£c v·ªã tr√≠ c·ªßa em trong tim anh.",
    "C·∫£m ∆°n em v√¨ ƒë√£ ƒë·∫øn v√† l√†m anh h·∫°nh ph√∫c.",
    "Anh kh√¥ng c·∫ßn g√¨ c·∫£, ch·ªâ c·∫ßn c√≥ em l√† ƒë·ªß."
];

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const sceneContainer = document.getElementById('scene-container'); 

let W = window.innerWidth, H = window.innerHeight;

// --- LO·∫†I B·ªé C√ÅC BI·∫æN LI√äN QUAN ƒê·∫æN XOAY ---
 let currentSceneRotateX = 0; 
 let currentSceneRotateY = 0; 
 let targetRotateX = 0;       
let targetRotateY = 0;       
 let lastInputX = 0, lastInputY = 0;
 let isDragging = false;

const FOCAL_LENGTH = 600; // Ti√™u c·ª± cho chi·∫øu ph·ªëi c·∫£nh 3D (gi·ªØ l·∫°i n·∫øu mu·ªën chi·ªÅu s√¢u)

function resizeCanvas() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
    fillHearts();
    fillTexts();
}

const heartImagePaths = [
    'img/heart (1).png', 'img/heart (2).png', 'img/heart (3).png', 'img/heart.png',
    'img/hearts.png', 'img/like.png', 'img/love (1).png', 'img/love.png'
];
const loadedHeartImages = [];
heartImagePaths.forEach(path => {
    const img = new Image();
    img.src = path;
    img.onerror = () => { console.error(`Kh√¥ng th·ªÉ t·∫£i ·∫£nh: ${path}`); };
    loadedHeartImages.push(img);
});

const hearts = [];
function randomHeart() {
    const randomImg = loadedHeartImages[Math.floor(Math.random() * loadedHeartImages.length)]; 
    const baseSize = 18 + Math.random() * 18;
    const z = Math.random() * FOCAL_LENGTH - FOCAL_LENGTH / 2; // Gi·ªØ l·∫°i Z ƒë·ªÉ c√≥ chi·ªÅu s√¢u
    return {
        x: Math.random() * W,
        y: -30 - Math.random() * H,
        baseSize: baseSize,
        size: baseSize,
        speed: 1.5 + Math.random() * 2.5,
        img: randomImg,
        z: z 
    };
}
function fillHearts() {
    hearts.length = 0;
    const numHearts = Math.floor(W / 10);
    for (let i = 0; i < numHearts; i++) { hearts.push(randomHeart()); }
}

const texts = [];
function randomText() {
    const baseSize = 18 + Math.random() * 18;
    const z = Math.random() * FOCAL_LENGTH - FOCAL_LENGTH / 2; // Gi·ªØ l·∫°i Z ƒë·ªÉ c√≥ chi·ªÅu s√¢u
    return {
        text: loveWords[Math.floor(Math.random() * loveWords.length)],
        x: Math.random() * W,
        y: -30 - Math.random() * H,
        baseSize: baseSize,
        size: baseSize,
        speed: 1.5 + Math.random() * 2.5,
        angle: (Math.random() - 0.5) * 0.3, 
        z: z 
    };
}
function fillTexts() {
    texts.length = 0;
    const numTexts = Math.floor(W / 40);
    for (let i = 0; i < numTexts; i++) { texts.push(randomText()); }
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// --- LO·∫†I B·ªé T·∫§T C·∫¢ C√ÅC H√ÄM V√Ä LISTENER X·ª¨ L√ù K√âO/XOAY ---

function startDragging(clientX, clientY) {
    isDragging = true;
    lastInputX = clientX;
    lastInputY = clientY;
}

function moveDragging(clientX, clientY) {
    if (!isDragging) return;
    const sensitivity = 0.2;
    const deltaX = (clientX - lastInputX) * sensitivity;
    const deltaY = (clientY - lastInputY) * sensitivity;

    targetRotateY += deltaX;
    targetRotateX -= deltaY;

    lastInputX = clientX;
    lastInputY = clientY;
}

function stopDragging() {
    isDragging = false;
}

canvas.addEventListener('mousedown', (e) => {
    startDragging(e.clientX, e.clientY);
});
canvas.addEventListener('mousemove', (e) => {
    moveDragging(e.clientX, e.clientY);
});
canvas.addEventListener('mouseup', stopDragging);
canvas.addEventListener('mouseleave', stopDragging);

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
        startDragging(e.touches[0].clientX, e.touches[0].clientY);
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
        moveDragging(e.touches[0].clientX, e.touches[0].clientY);
    }
}, { passive: false });

canvas.addEventListener('touchend', stopDragging);
canvas.addEventListener('touchcancel', stopDragging);


// --- LO·∫†I B·ªé H√ÄM C·∫¨P NH·∫¨T XOAY 3D V√Ä G·ªåI N√ì ---

function update3DRotation() {
    if (sceneContainer) {
        currentSceneRotateX += (targetRotateX - currentSceneRotateX) * 0.1;
        currentSceneRotateY += (targetRotateY - currentSceneRotateY) * 0.1;

        sceneContainer.style.transform = `rotateX(${currentSceneRotateX}deg) rotateY(${currentSceneRotateY}deg)`;
    }
    requestAnimationFrame(update3DRotation);
}
update3DRotation();


// H√†m chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô 3D v√† chi·∫øu v·ªÅ 2D (ch·ªâ c√≤n chi·∫øu ph·ªëi c·∫£nh theo Z)
// V√¨ kh√¥ng xoay, currentSceneRotateX v√† currentSceneRotateY s·∫Ω lu√¥n l√† 0
function transformAndProject3D(originalX, originalY, originalZ) {
     const radRotateX = currentSceneRotateX * Math.PI / 180; // S·∫Ω l√† 0
     const radRotateY = currentSceneRotateY * Math.PI / 180; // S·∫Ω l√† 0

    const sceneCenterX = W / 2;
    const sceneCenterY = H / 2;

    let pX = originalX - sceneCenterX;
    let pY = originalY - sceneCenterY;
    let pZ = originalZ;

    // --- LO·∫†I B·ªé PH√âP XOAY TRONG H√ÄM N√ÄY ---
    
    let tempY = pY * Math.cos(radRotateX) - pZ * Math.sin(radRotateX);
    let tempZ = pY * Math.sin(radRotateX) + pZ * Math.cos(radRotateX);
    pY = tempY;
    pZ = tempZ;

    let tempX = pX * Math.cos(radRotateY) + pZ * Math.sin(radRotateY);
    tempZ = -pX * Math.sin(radRotateY) + pZ * Math.cos(radRotateY);
    pX = tempX;
    pZ = tempZ;
    

    if (FOCAL_LENGTH - pZ <= 0) {
        return { px: -1000, py: -1000, scale: 0.001, finalZ: pZ };
    }

    const scale = FOCAL_LENGTH / (FOCAL_LENGTH - pZ);

    const px = pX * scale + sceneCenterX;
    const py = pY * scale + sceneCenterY;
    
    return { px, py, scale, finalZ: pZ };
}

function animate() {
    ctx.clearRect(0, 0, W, H);

    const allElements = [...hearts, ...texts].sort((a, b) => a.z - b.z);

    for (let elem of allElements) {
        elem.y += elem.speed;

        const { px, py, scale, finalZ } = transformAndProject3D(elem.x, elem.y, elem.z);
        elem.size = elem.baseSize * scale;

        if (scale > 0.05 && finalZ < FOCAL_LENGTH) {
            if (elem.img) {
                if (elem.img.complete) {
                    ctx.drawImage(elem.img, px - elem.size / 2, py - elem.size / 2, elem.size, elem.size);
                }
            } else { // N·∫øu l√† ch·ªØ
                ctx.save();
                ctx.translate(px, py);

                // --- CH·ªà S·ª¨ D·ª§NG G√ìC XOAY NG·∫™U NHI√äN BAN ƒê·∫¶U C·ª¶A CH·ªÆ ---
                ctx.rotate(elem.angle); 
                // --- LO·∫†I B·ªé C√ÅC T√çNH TO√ÅN G√ìC XOAY ƒê·ªòNG D·ª∞A TR√äN XOAY C·∫¢NH ---
                
                const textRelativeToCenterX = elem.x - (W / 2); 
                const textRotationInfluenceFactor = 0.005; 
                const dynamicAngleX = textRelativeToCenterX * textRotationInfluenceFactor * (currentSceneRotateY * Math.PI / 180);
                ctx.rotate(elem.angle + dynamicAngleX);
                
                // -------------------------------------------------------------------

                ctx.font = `bold ${elem.size}px sans-serif`;
                const opacity = Math.min(1, Math.max(0.2, scale * 1.5));
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`; 
                ctx.textAlign = "center";
                ctx.shadowColor = "#ff69b4";
                ctx.shadowBlur = Math.min(15, 8 * scale);

                ctx.fillText(elem.text, 0, 0);
                ctx.restore();
            }
        }

        if (py > H + elem.size || py < -elem.size || px > W + elem.size || px < -elem.size || finalZ > FOCAL_LENGTH * 0.95 || finalZ < -FOCAL_LENGTH * 0.95) {
            Object.assign(elem, elem.img ? randomHeart() : randomText());
            elem.y = -elem.baseSize - Math.random() * H * 0.5; 
            elem.x = Math.random() * W;
        }
    }

    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>

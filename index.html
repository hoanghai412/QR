<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Hearts & Love Words</title>
    <style>
        html, body {
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
            overflow: hidden;
            background: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            perspective: 1000px; 
        }
        canvas { display: block; }

        #scene-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            transform-style: preserve-3d; 
            transform: rotateX(0deg) rotateY(0deg); 
            transition: transform 0.1s ease-out; 
            transform-origin: center center; 
        }
    </style>
</head>
<body>

<div id="scene-container">
    <canvas id="c"></canvas>
</div>

<script>
const loveWords = [
    "Anh th∆∞∆°ng em nhi·ªÅu l·∫Øm üíñ",
    "Ch·ªâ c·∫ßn l√† em, anh ch·∫•p nh·∫≠n t·∫•t c·∫£.",
    "Em l√† ƒëi·ªÅu ng·ªçt ng√†o nh·∫•t trong cu·ªôc ƒë·ªùi anh.",
    "M·ªói ng√†y c√≥ em l√† m·ªói ng√†y h·∫°nh ph√∫c.",
    "Anh ch·ªâ mu·ªën n·∫Øm tay em ƒëi h·∫øt cu·ªôc ƒë·ªùi n√†y.",
    "G·∫∑p ƒë∆∞·ª£c em l√† ƒëi·ªÅu may m·∫Øn nh·∫•t ƒë·ªùi anh.",
    "Anh mu·ªën ·ªü b√™n em, m√£i m√£i kh√¥ng r·ªùi.",
    "Ch·ªâ c·∫ßn em c∆∞·ªùi, c·∫£ th·∫ø gi·ªõi c·ªßa anh s√°ng l√™n.",
    "Em c√≥ bi·∫øt anh nh·ªõ em ƒë·∫øn nh∆∞·ªùng n√†o kh√¥ng?",
    "Em l√† gi·∫•c m∆° ƒë·∫πp nh·∫•t c·ªßa anh.",
    "D√π th·∫ø n√†o ƒëi n·ªØa, anh v·∫´n lu√¥n ·ªü ƒë√¢y v√¨ em.",
    "Y√™u em l√† ƒëi·ªÅu tuy·ªát v·ªùi nh·∫•t anh t·ª´ng l√†m.",
    "Anh h·ª©a s·∫Ω lu√¥n b√™n em, b·∫£o v·ªá v√† y√™u em.",
    "Tim anh ƒë√£ l·ª° nh·ªãp k·ªÉ t·ª´ ng√†y g·∫∑p em.",
    "Th·∫ø gi·ªõi n√†y ƒë·∫πp h∆°n v√¨ c√≥ em.",
    "Anh y√™u em h∆°n c·∫£ ng√¥n t·ª´ c√≥ th·ªÉ di·ªÖn t·∫£.",
    "Ch·ªâ c·∫ßn l√† em, m·ªçi ƒëi·ªÅu ƒë·ªÅu tr·ªü n√™n ƒë√°ng gi√°.",
    "Kh√¥ng ai thay th·∫ø ƒë∆∞·ª£c v·ªã tr√≠ c·ªßa em trong tim anh.",
    "C·∫£m ∆°n em v√¨ ƒë√£ ƒë·∫øn v√† l√†m anh h·∫°nh ph√∫c.",
    "Anh kh√¥ng c·∫ßn g√¨ c·∫£, ch·ªâ c·∫ßn c√≥ em l√† ƒë·ªß."
];

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const sceneContainer = document.getElementById('scene-container'); 

let W = window.innerWidth, H = window.innerHeight;

let currentSceneRotateX = 0; 
let currentSceneRotateY = 0; 
let targetRotateX = 0;       
let targetRotateY = 0;       
let lastInputX = 0, lastInputY = 0;
let isDragging = false;

const FOCAL_LENGTH = 600; 

function resizeCanvas() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
    fillHearts();
    fillTexts();
}

const heartImagePaths = [
    'img/heart (1).png', 'img/heart (2).png', 'img/heart (3).png', 'img/heart.png',
    'img/hearts.png', 'img/like.png', 'img/love (1).png', 'img/love.png'
];
const loadedHeartImages = [];
heartImagePaths.forEach(path => {
    const img = new Image();
    img.src = path;
    img.onerror = () => { console.error(`Kh√¥ng th·ªÉ t·∫£i ·∫£nh: ${path}`); };
    loadedHeartImages.push(img);
});

const hearts = [];
function randomHeart() {
    const randomImg = loadedHeartImages[Math.floor(Math.random() * loadedHeartImages.length)]; 
    const baseSize = 18 + Math.random() * 18;
    const z = Math.random() * FOCAL_LENGTH - FOCAL_LENGTH / 2; 
    return {
        x: Math.random() * W,
        y: -30 - Math.random() * H,
        baseSize: baseSize,
        size: baseSize,
        speed: 1.5 + Math.random() * 2.5,
        img: randomImg,
        z: z 
    };
}
function fillHearts() {
    hearts.length = 0;
    const numHearts = Math.floor(W / 20);
    for (let i = 0; i < numHearts; i++) { hearts.push(randomHeart()); }
}

const texts = [];
function randomText() {
    const baseSize = 18 + Math.random() * 18;
    const z = Math.random() * FOCAL_LENGTH - FOCAL_LENGTH / 2;
    return {
        text: loveWords[Math.floor(Math.random() * loveWords.length)],
        x: Math.random() * W,
        y: -30 - Math.random() * H,
        baseSize: baseSize,
        size: baseSize,
        speed: 1.5 + Math.random() * 2.5,
        angle: 0, 
        z: z 
    };
}
function fillTexts() {
    texts.length = 0;
    const numTexts = Math.floor(W / 100);
    for (let i = 0; i < numTexts; i++) { texts.push(randomText()); }
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

function startDragging(clientX, clientY) {
    isDragging = true;
    lastInputX = clientX;
    lastInputY = clientY;
}

function moveDragging(clientX, clientY) {
    if (!isDragging) return;
    const sensitivity = 0.2;
    const deltaX = (clientX - lastInputX) * sensitivity;
    const deltaY = (clientY - lastInputY) * sensitivity;

    targetRotateY += deltaX;
    targetRotateX -= deltaY;

    lastInputX = clientX;
    lastInputY = clientY;
}

function stopDragging() {
    isDragging = false;
    targetRotateX = 0; 
    targetRotateY = 0; 
    console.log('--- Drag stopped --- Target X:', targetRotateX, 'Target Y:', targetRotateY);
}

canvas.addEventListener('mousedown', (e) => {
    startDragging(e.clientX, e.clientY);
});
canvas.addEventListener('mousemove', (e) => {
    moveDragging(e.clientX, e.clientY);
});
canvas.addEventListener('mouseup', stopDragging);
canvas.addEventListener('mouseleave', stopDragging); 

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
        startDragging(e.touches[0].clientX, e.touches[0].clientY);
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
        moveDragging(e.touches[0].clientX, e.touches[0].clientY);
    }
}, { passive: false
